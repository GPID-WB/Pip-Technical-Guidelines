---
abstract: This document outlines **suggested** guidelines for using GitHub Copilot, ensuring best-practice tips meant to improve efficiency and quality of your technical work.
execute:
  eval: true
comments:
  hypothesis: true
# bibliography: AI2.bib
number-sections: false
---

# Suggested Guidelines for Using GitHub Copilot in Technical Work {#sec-copilot-guidelines}

## Purpose and Principles

```{r}
#| echo: false
#| results: false
source("R/helpers.R")

```

GitHub Copilot is a powerful tool that can accelerate development, help you explore solutions, and reduce repetitive coding tasks. However, it works best when you know how to communicate effectively with it and when you maintain critical judgment about its suggestions.

This document provides **suggested guidelines** (not mandatory protocols) for using Copilot more effectively. These tips are designed to help you:

1. **Get better results faster** — learn how to prompt Copilot effectively so you spend less time iterating.
2. **Maintain code quality** — understand how to verify, refine, and improve Copilot's suggestions.
3. **Work securely** — avoid accidentally sharing sensitive data or introducing security risks.
4. **Build reusable workflows** — create prompt patterns you can share with teammates and reuse across projects.
5. **Stay in control** — use Copilot as an assistant, not a replacement for your engineering judgment.

These guidelines complement the mandatory protocols outlined in the Copilot Protocols document. While protocols define what you *must* do for code reviews and formal tasks, these guidelines help you work more efficiently day-to-day. 

We will suggest some prompts to apply this guidelines but feel free to modified them as needed to fit your specific context and projects.

### Where the suggested Prompt Files Live

The shared prompts are stored in the repository [GPID-WB/copilot-prompts](https://github.com/GPID-WB/copilot-prompts).  The prompt files for these guidelines are in the folder `guidelines/`.

```
prompts/
gpid-guide-complete-prompt.prompt.md

```

To include these prompts in your IDE, you can clone the repository and then import the relevant prompt files into your Copilot setup. See the installation instructions: [One-Time Installation (Per Developer)](copilot_protocols.qmd#one-time-installation). Make sure to add the `guidelines/` subfolder, as well as the `protocols/` subfolder.

::: {.callout-tip}
Think of these guidelines as best practices that will save you time and help you get the most value from Copilot without compromising quality or security.
:::

---

## Prompt engineering

One of the most important skills to develop when using Githup Copilot, or any other AI agent, is to know how to prompt. Github provides some guidelines on [Prompt engineering for Github Copilot Chat](https://docs.github.com/en/copilot/concepts/prompting/prompt-engineering), but here are the main points to take into consideration:

- Start general and then specific
- Provide examples
- Break complex tasks into simpler tasks
- Reread your prompt and avoid ambiguity 
- Indicate relevant code (select a file or highlight the specific piece of code)  
- Experiment and iterate until you find a useful answer
- Keep history relevant and delete requests that are not longer relevant

### The Do's and Don'ts when prompting

Useful action verbs / short commands (with example sentences):

- Analyze — "Analyze this function and list potential edge cases."
- Explain — "Explain what this block of code does in plain language."
- Refactor — "Refactor this function for readability and add comments."
- Test — "Write unit tests for this function covering typical and edge cases."
- Summarize — "Summarize the responsibilities of each module in one paragraph."
- Optimize — "Optimize this loop for performance and explain changes."
- Validate — "Validate input handling and add defensive checks."
- Suggest — "Suggest alternative implementations that reduce memory usage."
- Document — "Add Roxygen2-style documentation for these functions."
- Critique — "Critique this code and point out risks or unclear logic."

Best prompt structure (brief):

1. Context: state which files, functions, or data the agent should consider.
2. Task: give a clear action using a verb (from the list above).
3. Constraints: list any requirements or restrictions (style, libraries, performance).
4. Examples/output: show a small input/output example or the desired format for the answer.

::: {.callout-note icon="false" appearance="simple"}
## Example

Context: file utils.R (functions read_data, clean_data). Task: Write unit tests for clean_data. Constraints: use testthat, cover edge cases for NA and invalid types. Output: provide test code only.
:::

What to avoid when creating prompts:

- Vague or ambiguous instructions (avoid "fix this" without context).
- Overloading a single prompt with many unrelated tasks.
- Including sensitive data (secrets, passwords, personal data).
- Assuming the agent knows private or internal project details not provided in the prompt.
- Requests that rely on unstated external state (unspecified files, databases, or services).

Note on links and security: be cautious when including or following external links in prompts or Copilot responses—links may expose or lead to insecure resources and can present a security risk.

**Prompt suggested:**

```
/gpid-guide-complete-prompt
```

#### Latest GPID prompt file {.unnumbered}

::: {.callout-note collapse="true" title="gpid-guide-complete-prompt"}

```{r}
#| echo: false
#| results: asis
#| code-fold: true
embed_gpid_prompt("gpid-guide-complete-prompt.prompt.md", folder = "guidelines")

```

:::

### Security Considerations for Prompts

When creating prompts, follow these guidelines to protect organizational data and avoid security risks:

**Never include sensitive data:**
- Avoid pasting credentials, API keys, passwords, tokens, or authentication secrets.
- Do not include personally identifiable information (PII) or confidential business data.
- Exclude proprietary algorithms or internal business logic.

**Sanitize code before sharing:**
- Remove or redact hardcoded secrets, connection strings, or environment variables.
- Replace real identifiers with placeholders (e.g., `<DB_NAME>`, `<API_ENDPOINT>`).
- Avoid exposing internal directory structures, server names, or infrastructure details.

**Verify external resources:**
- Do not blindly follow or execute code from links provided by Copilot.
- Validate suggested packages, libraries, or URLs against trusted sources before installation.
- Be aware that suggested resources may be outdated, compromised, or malicious.

**Review generated code:**
- Check for security vulnerabilities (SQL injection, command injection, unsafe file operations).
- Verify that code follows secure coding practices (input validation, error handling, least privilege).

**Keep context minimal:**
- Only provide the minimum code/context necessary to answer your question.
- Follow the organization's data classification and handling policies.

**Prompt suggested:**

```
/gpid-guide-security
```

#### Latest GPID prompt file {.unnumbered}

::: {.callout-note collapse="true" title="gpid-guide-security"}

```{r}
#| echo: false
#| results: asis
#| code-fold: true
embed_gpid_prompt("gpid-guide-security.prompt.md", folder = "guidelines")

```

:::

### Reusable prompts

Same as the prompt above, you can create useful reusable prompts that can help you save time and can also be shared with team members. For example, you can make the prompts from the Protocol section as a reusable prompts. VSCode gives a good explanation of how these can created in its [Copilot Tips and Tricks](https://code.visualstudio.com/docs/copilot/copilot-tips-and-tricks#_reusable-prompts). 

### Premium Advantages

GitHub Copilot offers access to both standard models (included in your subscription) and premium models (Anthropic Claude, Google Gemini, OpenAI o1, and others). Choosing the right model for each task balances capability, cost, speed, and operational constraints. This section provides practical guidance on when to use premium models and when the standard model is sufficient.

**When to use premium models**

Premium models excel at tasks where their advanced reasoning, longer context windows, or specialized capabilities substantially reduce iteration time or improve output quality:

- **Complex multi-step reasoning:** Tasks requiring multi-step data transformations, advanced statistical or causal inference explanations, intricate code synthesis across multiple files, or deep logical analysis. Premium models handle these more reliably with fewer hallucinations and contradictions.

- **High-stakes correctness:** When errors have significant downstream costs—policy notes, model specifications, reproducible analysis pipelines, security-sensitive code, or regulatory reporting—premium models' improved accuracy and safer outputs reduce review cycles and minimize risk.

- **Long-context workflows:** If your task requires understanding many files (10+ modules), long notebooks (500+ lines), or extended prompt histories, premium models with larger context windows (100K+ tokens) avoid manual summarization and preserve continuity across complex conversations.

- **Nuanced language and domain adaptation:** Tasks demanding precise adherence to style, domain-specific terminology (economics, statistics, legal language), or advanced rewriting for technical reports, policy briefs, or executive summaries. Premium models produce higher-quality, more contextually appropriate text.

- **Multi-modal or advanced tool usage:** When the model must handle code + charts + tables simultaneously, or integrate with external tools (APIs, retrieval systems, databases), premium models provide more robust reasoning and clearer explanation of multi-step operations.

**When to use standard models**

Standard models are cost-effective and sufficient for most routine development tasks. Use them when speed, cost, and throughput matter more than advanced reasoning:

- **Routine code generation:** Simple function implementations, standard CRUD operations, boilerplate generation, or straightforward refactoring tasks where the logic is well-established and low-risk.

- **Exploratory work and prototyping:** Early-stage brainstorming, quick drafts, proof-of-concept scripts, or iterative experimentation where you expect to revise heavily and speed matters more than perfection.

- **Small-scale edits:** Single-file changes, adding comments or documentation, formatting fixes, or minor bug corrections where context is limited and the task is well-defined.

- **Batch operations:** Many small, independent requests (batch refactoring, generating test stubs for 50+ functions, or repetitive code transformations) where latency and cost per request are priorities.

- **Low-stakes content:** Internal notes, preliminary analysis drafts, or documentation that will undergo extensive human review and editing regardless of model quality.

**Decision framework: when is capability the bottleneck?**

Switch from standard to premium models when you observe these signs that capability (not cost or speed) is limiting your progress:

- Repeated iterations produce inconsistent, contradictory, or incomplete outputs despite clear prompts.
- You must constantly break context into many small prompts or manually summarize because the model "forgets" earlier parts of the conversation.
- Errors persist that look like reasoning failures or hallucinations rather than simple bugs (e.g., incorrect statistical interpretations, flawed causal logic, or fabricated function signatures).
- The time spent iterating with the standard model exceeds the marginal cost of using a premium model (typically after 3-5 failed attempts on complex tasks).

**Practical workflow**

1. **Start with standard models** for initial prototyping, exploration, and routine tasks. This keeps costs low and iteration fast.
2. **Switch to premium models** when the task requires high accuracy, long context, complex reasoning, or when standard model iterations are failing or taking too long.
3. **Use premium models for final synthesis** on high-stakes deliverables: polishing policy documents, validating complex pipelines, or generating production-ready code with rigorous error handling.
4. **Document your choice:** Note which model you used and why in your prompt record (see "Document prompts used for key tasks") to support reproducibility and cost tracking.

**Trade-offs and constraints**

- **Cost:** Premium models are 5-20x more expensive per request. Reserve them for tasks where reduced iteration time or higher quality justifies the cost.
- **Latency:** Premium models may have higher response times (2-10 seconds vs. <1 second). For interactive workflows, this can slow down rapid iteration.
- **Data governance:** Verify provider contracts and data handling policies before sending sensitive data. Some premium offerings include enterprise contracts with stronger confidentiality protections—use those for proprietary or sensitive work.
- **Availability and rate limits:** Premium models may have different quotas, API limits, or integration requirements. Confirm operational constraints before committing to them in automated pipelines.

**Examples**

- **Premium:** "Design an analysis pipeline that reads microdata from five countries, harmonizes variable definitions, implements a difference-in-differences estimator with sensitivity analysis, generates reproducible R code with unit tests, and drafts a two-page summary of findings for a policy note." (Complex, multi-step, high-stakes.)
- **Standard:** "Write a helper function that converts country codes from ISO2 to ISO3 format using the countrycode package." (Simple, low-risk, single-file.)
- **Premium:** "Review this 800-line poverty estimation script, identify edge cases that could cause incorrect poverty headcount calculations, and suggest defensive checks." (Long context, high correctness requirement.)
- **Standard:** "Add Roxygen2 documentation to these three short utility functions." (Routine, low-stakes, well-defined.)

This approach ensures you use premium models where they provide measurable value while keeping costs manageable for routine work.

## Interaction with GitHub Copilot

### First Ask, then Agent: map and agree the solution before making changes

Before asking Copilot to modify code (Agent mode), first use the Ask option to explore and agree a solution for the general task. Have Copilot propose a design and refine it until you and the agent share the same approach — this helps avoid unnecessary edits and keeps reviews small.

::: {.callout-note icon="false" appearance="simple"}
## Examples of Ask prompts

- "What functions would be needed to implement this feature?"
- "How would these functions interact? Describe the workflow or provide a brief diagram." 
- "For each new function, give a short summary: objective, inputs, outputs, and dependencies." 
- "What modifications to existing functions are required? List changes and rationale."
:::

Once the design is mapped and agreed, switch to Agent mode and request the specific code changes. You can iterate on alternatives and trade-offs in Ask mode before implementing. This workflow reduces code churn and the amount of code you must inspect.

### Provide Feedback to Improve Future Suggestions

GitHub Copilot learns from your feedback to improve the quality and relevance of future suggestions. Providing feedback helps the AI agent understand what works well and what doesn't.

**How to give feedback:**

- Use thumbs up/down buttons on suggestions or responses when available in the Copilot interface.
- Explicitly tell Copilot when a response is helpful or unhelpful (e.g., "This solution works well" or "This approach doesn't fit our requirements").
- If a suggestion is incorrect or incomplete, explain why and ask for a revised version with specific corrections.
- Accept or reject inline code suggestions to signal which patterns align with your codebase.

**Why feedback is important:**

- Helps Copilot adapt to your coding style, preferred libraries, and project conventions over time.
- Improves the accuracy of future suggestions for similar tasks.
- Signals to the model which responses are most useful, contributing to better performance.
- Saves time by reducing iterations needed to get the right answer.

Providing clear, specific feedback (rather than just rejecting suggestions) yields the best results for improving Copilot's future responses.

### Document prompts used for key tasks

When using Github Copilot to work on tasks that will need revision by team members, a good idea will be to record the key characteristics of prompts you used. At minimum, ask Github Copilot to capture:

- The context provided (if any): files, code snippets, or system state included with the prompt (what the agent "saw").
- The Agent instruction: the explicit task or role you asked the agent to perform (for example, "write a unit test", "refactor this function for readability", or "explain this algorithm").

Other useful prompt characteristics to document:

- Input data examples (small sample inputs and expected outputs).
- Any constraints or hard requirements (performance limits, libraries to use, coding style).
- Time or version metadata (date, version of Copilot/IDE/plugins if known).

Why this helps: keeping a short record of the prompts and their context makes it easier to reproduce results, re-run or refine prompts, and debug situations where generated code fails or causes errors. These notes become especially valuable during future development when tracking regressions or when onboarding colleagues who must understand the original intent.

**Prompt suggested:**

```
/gpid-guide-document-task
```

#### Latest GPID prompt file {.unnumbered}

::: {.callout-note collapse="true" title="gpid-guide-document-task"}

```{r}
#| echo: false
#| results: asis
#| code-fold: true
embed_gpid_prompt("gpid-guide-document-task.prompt.md", folder = "guidelines")

```

:::

## Other resources
- [GitHub Copilot in your IDE](https://github.blog/developer-skills/github/how-to-use-github-copilot-in-your-ide-tips-tricks-and-best-practices/?ref_product=copilot&ref_type=engagement&ref_style=text)
- [Github Copilot best practices](https://docs.github.com/en/copilot/get-started/best-practices)
- [Github Copilot tips and tricks in Vscode](https://code.visualstudio.com/docs/copilot/copilot-tips-and-tricks)
- [Mastering Github Copilot Chat](https://www.copilotcraft.dev/blog/mastering-github-copilot-chat)


