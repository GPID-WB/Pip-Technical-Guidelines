---
abstract: This document outlines **suggested** guidelines for using GitHub Copilot, ensuring best-practice tips meant to improve efficiency and quality of your technical work.
execute:
  eval: true
comments:
  hypothesis: true
# bibliography: AI2.bib
number-sections: false
---

# Suggested Guidelines for Using GitHub Copilot in Technical Work {#sec-copilot-guidelines}

## Purpose and Principles

```{r}
#| echo: false
#| results: false
source("R/helpers.R")

```

GitHub Copilot is a powerful tool that can accelerate development, help you explore solutions, and reduce repetitive coding tasks. However, it works best when you know how to communicate effectively with it and when you maintain critical judgment about its suggestions.

This document provides **suggested guidelines** (not mandatory protocols) for using Copilot more effectively. These tips are designed to help you:

1. **Get better results faster** — learn how to prompt Copilot effectively so you spend less time iterating.
2. **Maintain code quality** — understand how to verify, refine, and improve Copilot's suggestions.
3. **Work securely** — avoid accidentally sharing sensitive data or introducing security risks.
4. **Build reusable workflows** — create prompt patterns you can share with teammates and reuse across projects.
5. **Stay in control** — use Copilot as an assistant, not a replacement for your engineering judgment.

These guidelines complement the mandatory protocols outlined in the Copilot Protocols document. While protocols define what you *must* do for code reviews and formal tasks, these guidelines help you work more efficiently day-to-day. 

We will suggest some prompts to apply this guidelines but feel free to modified them as needed to fit your specific context and projects.

### Where the suggested Prompt Files Live

The shared prompts are stored in the repository [GPID-WB/copilot-prompts](https://github.com/GPID-WB/copilot-prompts).  The prompt files for these guidelines are in the folder `guidelines/`.

```
prompts/
gpid-guide-complete-prompt.prompt.md

```

To include these prompts in your IDE, you can clone the repository and then import the relevant prompt files into your Copilot setup. See the installation instructions: [One-Time Installation (Per Developer)](copilot_protocols.qmd#one-time-installation). Make sure to add the `guidelines/` subfolder, as well as the `protocols/` subfolder.

::: {.callout-tip}
Think of these guidelines as best practices that will save you time and help you get the most value from Copilot without compromising quality or security.
:::

---

## Prompt engineering

## Premium Advantages

This section explains when it is more efficient to use premium large language models (LLMs) such as Anthropic Claude, Google Gemini, or other higher-capability commercial models instead of the default Copilot models. The guidance focuses on practical trade-offs: capability, latency, cost, privacy, and operational fit.

- **Use premium models when task complexity is high:** prefer premium models for complex reasoning tasks (multi-step data transformations, advanced statistical reasoning, causal inference explanations, or complex code synthesis across multiple files) where higher-context windows and better reasoning substantially reduce iteration time.

- **Use premium models for high-stakes correctness:** when errors have substantial downstream costs (policy notes, model specification, reproducible analysis pipelines, or security-sensitive code), a premium model's improved accuracy and safer outputs reduce review cycles.

- **Use premium models for long-context workflows:** if your task requires understanding many files, long notebooks, or long prompt histories, premium models with larger context windows avoid manual summarization and preserve continuity across the conversation.

- **Use premium models for nuanced language and domain adaptation:** when you need better adherence to style, domain-specific terminology, or advanced rewriting (technical report polishing, precise policy phrasing, or data interpretation for non-technical audiences), premium models tend to produce higher-quality, more human-like text.

- **Use premium models for multi-modal or advanced tool usage:** where the model must handle code + charts + tables, or integrate with tools (APIs, retrieval systems), premium models often provide more robust, reliable integrations and clearer reasoning steps.

Trade-offs and constraints

- **Cost:** premium models are more expensive. Reserve them for tasks where the time saved or the reduction in review burden justifies the cost. For exploratory work, drafts, or low-risk scripting, the default Copilot model is usually sufficient.

- **Latency and throughput:** premium models can have higher latency and lower throughput in bulk operations. For batch processing or many small requests, prefer cheaper, faster models unless capability is the bottleneck.

- **Data governance and confidentiality:** verify provider contracts and data handling policies before sending sensitive data to any external model. Some premium offerings include enterprise contracts with stronger data protections—use those when confidentiality matters.

- **Availability and integration:** premium models may have different integration mechanisms, rate limits, or UI/SDK support. Confirm operational constraints (API keys, quotas, and SDK compatibility) before adopting them in an automated pipeline.

Practical examples

- Prefer premium models when asking: "Design an analysis pipeline that uses multiple files, explains the causal identification strategy, drafts R code to implement it, and creates unit tests." This single, complex request benefits from higher reasoning and longer context.

- Use default Copilot for: short refactors, small function implementations, or routine unit test scaffolding where speed and cost-efficiency are priorities.

- Use premium models for final-pass editing of policy text, executive summaries, or other documents that require nuance, tone control, and low tolerance for errors.

Suggested workflow

1. Start with the default Copilot to prototype and iterate quickly on ideas or code.
2. When the design stabilizes and you need higher-quality output, switch to a premium model for synthesis, long-context edits, or final polishing.
3. Document which model you used and why in your prompt record (see "Document prompts used for key tasks") to aid reproducibility and post-hoc review.

This approach balances cost and capability while ensuring higher-quality outputs when they matter most.


One of the most important skills to develop when using Githup Copilot, or any other AI agent, is to know how to prompt. Github provides some guidelines on [Prompt engineering for Github Copilot Chat](https://docs.github.com/en/copilot/concepts/prompting/prompt-engineering), but here are the main points to take into consideration:

- Start general and then specific
- Provide examples
- Break complex tasks into simpler tasks
- Reread your prompt and avoid ambiguity 
- Indicate relevant code (select a file or highlight the specific piece of code)  
- Experiment and iterate until you find a useful answer
- Keep history relevant and delete requests that are not longer relevant

### The Do's and Don'ts when prompting

Useful action verbs / short commands (with example sentences):

- Analyze — "Analyze this function and list potential edge cases."
- Explain — "Explain what this block of code does in plain language."
- Refactor — "Refactor this function for readability and add comments."
- Test — "Write unit tests for this function covering typical and edge cases."
- Summarize — "Summarize the responsibilities of each module in one paragraph."
- Optimize — "Optimize this loop for performance and explain changes."
- Validate — "Validate input handling and add defensive checks."
- Suggest — "Suggest alternative implementations that reduce memory usage."
- Document — "Add Roxygen2-style documentation for these functions."
- Critique — "Critique this code and point out risks or unclear logic."

Best prompt structure (brief):

1. Context: state which files, functions, or data the agent should consider.
2. Task: give a clear action using a verb (from the list above).
3. Constraints: list any requirements or restrictions (style, libraries, performance).
4. Examples/output: show a small input/output example or the desired format for the answer.

::: {.callout-note icon="false" appearance="simple"}
## Example

Context: file utils.R (functions read_data, clean_data). Task: Write unit tests for clean_data. Constraints: use testthat, cover edge cases for NA and invalid types. Output: provide test code only.
:::

What to avoid when creating prompts:

- Vague or ambiguous instructions (avoid "fix this" without context).
- Overloading a single prompt with many unrelated tasks.
- Including sensitive data (secrets, passwords, personal data).
- Assuming the agent knows private or internal project details not provided in the prompt.
- Requests that rely on unstated external state (unspecified files, databases, or services).

Note on links and security: be cautious when including or following external links in prompts or Copilot responses—links may expose or lead to insecure resources and can present a security risk.

**Prompt suggested:**

```
/gpid-guide-complete-prompt
```

#### Latest GPID prompt file {.unnumbered}

::: {.callout-note collapse="true" title="gpid-guide-complete-prompt"}

```{r}
#| echo: false
#| results: asis
#| code-fold: true
embed_gpid_prompt("gpid-guide-complete-prompt.prompt.md", folder = "guidelines")

```

:::

### Security Considerations for Prompts

When creating prompts, follow these guidelines to protect organizational data and avoid security risks:

**Never include sensitive data:**
- Avoid pasting credentials, API keys, passwords, tokens, or authentication secrets.
- Do not include personally identifiable information (PII) or confidential business data.
- Exclude proprietary algorithms or internal business logic.

**Sanitize code before sharing:**
- Remove or redact hardcoded secrets, connection strings, or environment variables.
- Replace real identifiers with placeholders (e.g., `<DB_NAME>`, `<API_ENDPOINT>`).
- Avoid exposing internal directory structures, server names, or infrastructure details.

**Verify external resources:**
- Do not blindly follow or execute code from links provided by Copilot.
- Validate suggested packages, libraries, or URLs against trusted sources before installation.
- Be aware that suggested resources may be outdated, compromised, or malicious.

**Review generated code:**
- Check for security vulnerabilities (SQL injection, command injection, unsafe file operations).
- Verify that code follows secure coding practices (input validation, error handling, least privilege).

**Keep context minimal:**
- Only provide the minimum code/context necessary to answer your question.
- Follow the organization's data classification and handling policies.

**Prompt suggested:**

```
/gpid-guide-security
```

#### Latest GPID prompt file {.unnumbered}

::: {.callout-note collapse="true" title="gpid-guide-security"}

```{r}
#| echo: false
#| results: asis
#| code-fold: true
embed_gpid_prompt("gpid-guide-security.prompt.md", folder = "guidelines")

```

:::

### Reusable prompts

Same as the prompt above, you can create useful reusable prompts that can help you save time and can also be shared with team members. For example, you can make the prompts from the Protocol section as a reusable prompts. VSCode gives a good explanation of how these can created in its [Copilot Tips and Tricks](https://code.visualstudio.com/docs/copilot/copilot-tips-and-tricks#_reusable-prompts). 


## Interaction with GitHub Copilot

### First Ask, then Agent: map and agree the solution before making changes

Before asking Copilot to modify code (Agent mode), first use the Ask option to explore and agree a solution for the general task. Have Copilot propose a design and refine it until you and the agent share the same approach — this helps avoid unnecessary edits and keeps reviews small.

::: {.callout-note icon="false" appearance="simple"}
## Examples of Ask prompts

- "What functions would be needed to implement this feature?"
- "How would these functions interact? Describe the workflow or provide a brief diagram." 
- "For each new function, give a short summary: objective, inputs, outputs, and dependencies." 
- "What modifications to existing functions are required? List changes and rationale."
:::

Once the design is mapped and agreed, switch to Agent mode and request the specific code changes. You can iterate on alternatives and trade-offs in Ask mode before implementing. This workflow reduces code churn and the amount of code you must inspect.

### Provide Feedback to Improve Future Suggestions

GitHub Copilot learns from your feedback to improve the quality and relevance of future suggestions. Providing feedback helps the AI agent understand what works well and what doesn't.

**How to give feedback:**

- Use thumbs up/down buttons on suggestions or responses when available in the Copilot interface.
- Explicitly tell Copilot when a response is helpful or unhelpful (e.g., "This solution works well" or "This approach doesn't fit our requirements").
- If a suggestion is incorrect or incomplete, explain why and ask for a revised version with specific corrections.
- Accept or reject inline code suggestions to signal which patterns align with your codebase.

**Why feedback is important:**

- Helps Copilot adapt to your coding style, preferred libraries, and project conventions over time.
- Improves the accuracy of future suggestions for similar tasks.
- Signals to the model which responses are most useful, contributing to better performance.
- Saves time by reducing iterations needed to get the right answer.

Providing clear, specific feedback (rather than just rejecting suggestions) yields the best results for improving Copilot's future responses.

### Document prompts used for key tasks

When using Github Copilot to work on tasks that will need revision by team members, a good idea will be to record the key characteristics of prompts you used. At minimum, ask Github Copilot to capture:

- The context provided (if any): files, code snippets, or system state included with the prompt (what the agent "saw").
- The Agent instruction: the explicit task or role you asked the agent to perform (for example, "write a unit test", "refactor this function for readability", or "explain this algorithm").

Other useful prompt characteristics to document:

- Input data examples (small sample inputs and expected outputs).
- Any constraints or hard requirements (performance limits, libraries to use, coding style).
- Time or version metadata (date, version of Copilot/IDE/plugins if known).

Why this helps: keeping a short record of the prompts and their context makes it easier to reproduce results, re-run or refine prompts, and debug situations where generated code fails or causes errors. These notes become especially valuable during future development when tracking regressions or when onboarding colleagues who must understand the original intent.

**Prompt suggested:**

```
/gpid-guide-document-task
```

#### Latest GPID prompt file {.unnumbered}

::: {.callout-note collapse="true" title="gpid-guide-document-task"}

```{r}
#| echo: false
#| results: asis
#| code-fold: true
embed_gpid_prompt("gpid-guide-document-task.prompt.md", folder = "guidelines")

```

:::

## Other resources
- [GitHub Copilot in your IDE](https://github.blog/developer-skills/github/how-to-use-github-copilot-in-your-ide-tips-tricks-and-best-practices/?ref_product=copilot&ref_type=engagement&ref_style=text)
- [Github Copilot best practices](https://docs.github.com/en/copilot/get-started/best-practices)
- [Github Copilot tips and tricks in Vscode](https://code.visualstudio.com/docs/copilot/copilot-tips-and-tricks)
- [Mastering Github Copilot Chat](https://www.copilotcraft.dev/blog/mastering-github-copilot-chat)


