---
title: "How to upgrade R"
execute:
  eval: false
---

R saves packages from minor versions and above.

set the .Renviron to read from a defined folder

Before upgrading you should save the name of all the packages

```{r}
pdkgs_names <- installed.packages() |> 
    _[,1]
saveRDS(pdkgs_names, "C:/some/dir/R_pkgs.RDS")
```

Ideally, once you have upgraded you should start a vanilla R session, which will ensure that the installation of packages does not conflict with each other. I recommend modifying your .Rprofile in the following way:

```{r}
next_R_session <- \(mode = c("regular", "vanilla"),
                  toggle_file = "~/.Rsession_toggle") {
  mode <- match.arg(mode)
  writeLines(mode, toggle_file)
  msg <- paste("Next session will be", mode)
  message(msg)
  invisible(msg)
}

toggle_file <- "~/.Rsession_toggle"

if (file.exists(toggle_file)) {
  mode <- readLines(toggle_file, warn = FALSE)
} else {
  mode <- "regular"
}


if (identical(mode, "vanilla")) {
  message("[startup] Vanilla-like session")

  ## 1) Flip the flag for next session
  writeLines("regular", toggle_file)

  ## 2) Clear the global environment (in case .RData was auto-restored)
  if (length(ls(envir = .GlobalEnv, all.names = TRUE))) {
    rm(list = ls(envir = .GlobalEnv, all.names = TRUE), envir = .GlobalEnv)
  }

  ## 3) Detach non-default attached packages
  keep_attached <- paste0("package:", c("stats","graphics","grDevices",
                                        "utils","datasets","methods","base"))
  for (att in setdiff(search(), keep_attached)) {
    # detaching “tools:…” or “Autoloads” can error; ignore failures
    try(detach(att, character.only = TRUE), silent = TRUE)
  }

  ## 4) Unload non-base namespaces
  keep_ns <- c("base","stats","graphics","grDevices","utils","datasets","methods")
  for (ns in setdiff(loadedNamespaces(), keep_ns)) {
    # some namespaces refuse to unload; ignore failures
    try(unloadNamespace(ns), silent = TRUE)
  }

  ## 5) Disable history writes this session
  if (.Platform$OS.type == "windows") {
    Sys.setenv(R_HISTFILE = "NUL")
  } else {
    Sys.setenv(R_HISTFILE = "/dev/null")
  }

  ## 6) Reduce noisy prompts/saves (approximate --no-save)
  # You can wrap quit() yourself if you want to enforce no-save on exit:
  # quit <- function(save = "no", ...) base::quit(save = save, ...)

  ## 7) Prevent renv auto-activation in projects
  Sys.setenv(RENV_CONFIG_AUTOLOADER_ENABLED = "FALSE")
  options(renv.consent = FALSE)

  message("Next session will be 'regular'. use `next_session()` to init vanilla")
  ## 8) IMPORTANT: DO NOT ADD anything else in this bracket
  ## Put ALL normal startup (options, library(), etc.) inside the else{} below.
} else {
  cli::cli_inform("Starting regular session...")
  
  # Here you add your regular .Rprofile code.
}


```

As you can see, the `next_R_session()` function allows to start a "sort of" vanilla session where you load nothing from the .Rprofile.

Once you have restarted the R session and are working now in a vanilla session, you have to remove the `.Last()` function if you don't want to work on vanilla forever.

```{r}
rm(.Last) 
```

Make sure the directory fot he new version of R exists in your folder. `e:/PovcalNet/01.personal/wb384996/R/win-library/`

Once you're in a new version of R, you need to make sure that the most important packages are already installed. This is what I do,

```{r}
install.packages(c("devtools", "roxygen2", "cli", "fs", "pak", "qs", "fst"))

```

```{r}
dir <- "P:/02.personal/wb384996/temporal/R/R_pkgs.RDS"
to_pkgs <- readRDS(dir)
in_pkgs <- installed.packages() |> 
  _[,1]

```

you can make use of your new library resambles the old one by folowing this

```{r}
# ------------------ R 4.5 migration helper (Windows-friendly) ------------------

# 0) Choose/confirm libraries ---------------------------------------------------
# new_lib is your first writable library for the *current* R (4.5.x)
new_lib <- .libPaths()[1]

# Derive the previous minor (4.4) sibling of new_lib automatically:
get_old_minor_lib <- function(new_lib) {
  # Expect .../win-library/4.5  ->  .../win-library/4.4
  parts <- strsplit(normalizePath(new_lib, winslash = "/"), "/")[[1]]
  if (length(parts) < 1L) return(NA_character_)
  
  ver <- parts[length(parts)]
  if (!grepl("^\\d+\\.\\d+$", ver)) return(NA_character_)
  
  majmin <- as.numeric(strsplit(ver, "\\.")[[1]])
  if (length(majmin) != 2L) return(NA_character_)
  
  old <- paste(majmin[1], majmin[2] - 1, sep = ".")
  parts[length(parts)] <- old
  old_lib <- paste(parts, collapse = "/")
  if (dir.exists(old_lib)) old_lib else NA_character_
}

old_lib <- get_old_minor_lib(new_lib)

if (is.na(old_lib)) {
  stop("Could not infer previous library path. Set `old_lib` manually, e.g.: ",
       "old_lib <- 'C:/Users/<you>/R/win-library/4.4'")
}

message("Old lib: ", old_lib)
message("New lib: ", new_lib)

# 1) Ensure prerequisite installers are present --------------------------------
safe_install_cran <- function(pkgs, lib = new_lib) {
  if (!length(pkgs)) return(invisible())
  repos <- getOption("repos")
  if (is.null(repos) || is.na(repos["CRAN"]) || repos["CRAN"] == "@CRAN@") {
    options(repos = c(CRAN = "https://cloud.r-project.org"))
  }
  # Windows: prefer binaries
  install.packages(pkgs, lib = lib, type = "binary", dependencies = TRUE)
}

need <- function(pkg) !requireNamespace(pkg, quietly = TRUE)

if (need("fs"))         safe_install_cran("fs")
if (need("remotes"))    safe_install_cran("remotes")


# Try installing pak; if it fails, we'll use remotes fallback
if (need("pak")) {
  # pak from CRAN since 0.7.0; if your CRAN is outdated, you can use r-lib repo:
  # safe_install_cran("pak")  # CRAN
  try(safe_install_cran("pak"), silent = TRUE)
}

# 2) Discover packages in the old library --------------------------------------
ip_old <- as.data.frame(utils::installed.packages(lib.loc = old_lib), stringsAsFactors = FALSE)

# Exclude base/recommended
ip_old <- subset(ip_old, is.na(Priority) | Priority == "")

# Already installed in new_lib?
ip_new <- rownames(installed.packages(lib.loc = new_lib))
todo   <- setdiff(ip_old$Package, ip_new)

if (!length(todo)) {
  message("Everything from the old library is already present in the new library.")
  quit(save = "no")
}

# Split by origin: CRAN vs not-CRAN (Repository present => CRAN-like)
cran <- intersect(todo, ip_old$Package[!is.na(ip_old$Repository)])
noncran <- setdiff(todo, cran)

# 3) Reconstruct GitHub refs for non-CRAN from DESCRIPTION ---------------------
desc_path <- function(pkg) file.path(old_lib, pkg, "DESCRIPTION")

parse_remote <- function(pkg) {
  p <- desc_path(pkg)
  if (!file.exists(p)) return(NA_character_)
  dcf <- tryCatch(read.dcf(p, all = TRUE)[1, ], 
                  error = function(e) NULL)
  if (is.null(dcf)) return(NA_character_)
  rt  <- tolower(dcf[["RemoteType"]])
  if (!is.na(rt) && rt == "github") {
    user <- dcf[["RemoteUsername"]]
    repo <- dcf[["RemoteRepo"]]
    ref  <- dcf[["RemoteRef"]]   # branch/tag/sha (optional)
    if (length(user) && nzchar(user) && length(repo) && nzchar(repo)) {
      return(if (length(ref) && nzchar(ref)) sprintf("%s/%s@%s", user, repo, ref)
             else sprintf("%s/%s", user, repo))
    }
  }
  # Fallback: some pkgs store GitHub in 'Remotes' (may be a list)
  rems <- dcf[["Remotes"]]
  if (!is.null(rems) && nzchar(rems)) {
    parts <- unlist(strsplit(gsub("[\r\n]", " ", rems), "[, ]+"))
    cand  <- grep("^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+(@[A-Za-z0-9_.-]+)?$",
                  parts, value = TRUE)
    if (length(cand)) return(cand[1])
  }
  NA_character_
}

gh_refs <- vapply(noncran, parse_remote, character(1))
gh_refs <- gh_refs[!is.na(gh_refs)]

# Anything left that's non-CRAN and not GitHub? We'll report it at the end.
leftover <- setdiff(noncran, names(gh_refs))

# 4) Install using pak if available; else fall back to base+remotes ------------
options(Ncpus = max(1L, parallel::detectCores(logical = TRUE) - 1L))

use_pak <- requireNamespace("pak", quietly = TRUE)

if (use_pak) {
  # Build pak refs: cran::pkg and github::user/repo[@ref]
  cran_refs <- if (length(cran)) paste0("cran::", cran) else character()
  pak_refs  <- unique(c(cran_refs,
                        if (length(gh_refs)) paste0("github::", gh_refs) else character()))
  message("Installing with pak (", length(pak_refs), " refs)...")
  pak::pkg_install(pak_refs, lib = new_lib, ask = FALSE, upgrade = TRUE)
} else {
  # CRAN (binaries on Windows)
  if (length(cran)) {
    message("Installing CRAN packages with install.packages(): ", paste(cran, collapse = ", "))
    safe_install_cran(cran, lib = new_lib)
  }
  # GitHub
  if (length(gh_refs)) {
    if (Sys.getenv("GITHUB_PAT") == "") {
      message("Tip: set GITHUB_PAT in ~/.Renviron to avoid GitHub rate limits.")
    }
    for (ref in gh_refs) {
      message("remotes::install_github('", ref, "')")
      try(remotes::install_github(ref, lib = new_lib, upgrade = "never",
                                  dependencies = TRUE), silent = TRUE)
    }
  }
}

# 5) Optional: Bioconductor packages you rely on -------------------------------
# If you know specific Bioc pkgs, list them here:
bioc_pkgs <- character(0)  # e.g., c("Biostrings", "DelayedArray")
if (length(bioc_pkgs) && requireNamespace("BiocManager", quietly = TRUE)) {
  BiocManager::install(bioc_pkgs, ask = FALSE, update = TRUE)
}

# 6) Report any remaining non-CRAN without a recovered GitHub ref --------------
still_missing <- setdiff(todo, rownames(installed.packages(lib.loc = new_lib)))
if (length(still_missing)) {
  message("\nStill missing after migration: ", paste(still_missing, collapse = ", "))
}
if (length(leftover)) {
  message("\nNon-CRAN packages without GitHub metadata (manual action may be needed): ",
          paste(leftover, collapse = ", "))
}

message("\nMigration attempt finished. New lib: ", new_lib)
# ------------------------------------------------------------------------------

```

Improved version

```{R}
local({
  r <- getOption("repos")
  # r["CRAN"] <- "https://cran.microsoft.com"
  r["CRAN"] = "https://cran.rstudio.com/"
  options(repos = r)
})



# 1) Ensure prerequisite installers are present --------------------------------
safe_install_cran <- function(pkgs, lib = new_lib) {
  if (!length(pkgs)) return(invisible())

  repos <- getOption("repos")
  if (is.null(repos) || is.na(repos["CRAN"]) || repos["CRAN"] == "@CRAN@") {
    options(repos = c(CRAN = "https://cloud.r-project.org"))
  }
  # Windows: prefer binaries
  utils::install.packages(pkgs, lib = lib, type = "binary", dependencies = TRUE)
  #.rs.restartR()
}

need <- \(pkg) {
  !requireNamespace(pkg, quietly = TRUE)
}


# Check library path

check_user_libs <- \() {
  current_lib <- .libPaths()[1] |>
    dirname()
  user_lib <-  Sys.getenv("R_LIBS_USER") |>
    dirname()

  if (!identical(current_lib, user_lib))  {
    stop("th edirectories of Sys.getenv('R_LIBS_USER') and .libPaths()[1] do not coincide.
         you may encounter issues in your installation of packages")
  }
  .libPaths()[1]
}
# 2 Install basic packages.
new_lib <- check_user_libs()

if (need("fs"))         safe_install_cran("fs")
if (need("fs"))         safe_install_cran("fs")
if (need("pak"))        safe_install_cran("pak")
if (need("remotes"))    safe_install_cran("remotes")



# 3 Identify old librearies

libdir  <- dirname(new_lib)
ver     <- basename(new_lib)

older_versions <- fs::dir_ls(libdir) |>
  fs::path_file() |>
  setdiff(ver)

previous_version <-
  older_versions[older_versions < ver] |>
  max(0)

if (previous_versions == 0) {
  stop("Could not infer previous library path. Set `old_lib` manually, e.g.:
       old_lib <- 'C:/Users/<you>/R/win-library/4.4'")
}

old_lib <- fs::path(libdir, previous_version)
old_lib <- new_lib


# 4) Discover packages in the old library
ip_old <- installed.packages(lib.loc = old_lib) |>
  as.data.frame(stringsAsFactors = FALSE) |>
  # Exclude base/recommended
  subset(is.na(Priority) | Priority == "")

# Already installed in new_lib?
ip_new <- rownames(installed.packages(lib.loc = new_lib))
todo   <- setdiff(ip_old$Package, ip_new)

if (length(todo) == 0) {
  stop("Everything from the old library is already present in the new library.")
}


```


## check folders
```r
# Print possible startup file locations
cat("Site .Renviron:", file.path(R.home("etc"), "Renviron"), "\n")
cat("User .Renviron:", path.expand("~/.Renviron"), "\n")
cat("Project .Renviron:", file.path(getwd(), ".Renviron"), "\n")
cat("Site .Rprofile:", file.path(R.home("etc"), "Rprofile"), "\n")
cat("User .Rprofile:", path.expand("~/.Rprofile"), "\n")
cat("Project .Rprofile:", file.path(getwd(), ".Rprofile"), "\n")

# Check which files exist
files <- c(
  file.path(R.home("etc"), "Renviron"),
  path.expand("~/.Renviron"),
  file.path(getwd(), ".Renviron"),
  file.path(R.home("etc"), "Rprofile"),
  path.expand("~/.Rprofile"),
  file.path(getwd(), ".Rprofile")
)
existing_files <- files[file.exists(files)]
cat("Startup files found and sourced in this session:\n")
print(existing_files)

```