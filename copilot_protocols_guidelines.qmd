---
title: "Protocols and Guidelines for Using GitHub Copilot in Technical Work"
abstract: Technical coding tasks (R, Stata), including data processing, automation, package development, and tool building.
execute:
  eval: false
---

## Purpose and Principles {.unnumbered}

GitHub Copilot is a powerful assistant that can increase productivity, generate boilerplate code quickly, and support experimentation. However, Copilot is not a substitute for engineering judgment, critical thinking, or expertise in R/Stata. This document establishes:

-   **Protocols** (mandatory actions) → must be followed and demonstrated during reviews.
-   **Guidelines** (recommended practices) → encourage effective, responsible use of AI.

Our goals:

1.  Improve productivity.
2.  Ensure robustness, maintainability, and security of code.
3.  Strengthen—not replace—team members’ coding skills.
4.  Prevent dependency creep, hallucinations, inefficiencies, and silent errors.

## PROTOCOLS (Mandatory Requirements)

Every team member **must** follow these protocols when using Copilot for technical work. Team leads will verify compliance during code reviews.

### **Protocol 1 — Documenting Your Work With Copilot**

**Objective:** We want every piece of Copilot-assisted work to be transparent, easy to review, and easy to understand—not only for you, but for anyone who touches the code later. Think of this as keeping a clear trail of “why we did what we did,” without drowning anyone in hundreds of lines of chat history.

#### **Start Every Copilot-Assisted Task With a Quick Declaration** {.unnumbered}

Whenever you’re about to use Copilot for something a particular task (specially the ones assigned to you), like rewriting a function, adding a feature, building tests, refactoring, among others, just let Copilot know you’re starting a task.

You can use this short message (literally "copy and paste." Just change the TASK_NAME):

::: {.callout-note icon="false" appearance="simple"}
## Prompt

I’m starting Task: [TASK_NAME]{.red}. Please keep a concise running summary of our interaction, including:

-   the major prompts I give
-   the important decisions we make
-   any dependencies added or removed
-   assumptions or limitations we identify At the end I’ll ask you to produce a markdown summary.
:::

Why do this? Because Copilot won’t track your whole conversation unless you tell it to. This little habit guarantees that your final summary is clean and complete.

------------------------------------------------------------------------

#### **Keep the Summary Updated as You Go (But Keep It Light)** {.unnumbered}

As you work, Copilot may try several ideas, produce alternatives, or suggest changes. When something important happens, simply say:

-   “Add this to the summary: we switched to data.table for speed.”
-   “Add this: the first approach was rejected because it created too many dependencies.”
-   “Record that we decided to remove purrr and use collapse instead.”

You don’t need to log every micro-step—just the meaningful ones.

This keeps your future self (and your reviewers) very happy.

------------------------------------------------------------------------

#### **When You Finish, Ask Copilot for a Clean Markdown Summary** {.unnumbered}

Once the task is done, ask Copilot:

::: {.callout-note icon="false" appearance="simple"}
## Prompt

Now generate a markdown summary of this task, including: - What the task was about - The key prompts I used - The major decisions or explanations you gave - Dependencies that were added, removed, or questioned - Any limitations or follow-up steps - The final version of the function or script - A short checklist showing how I followed the protocol

Save this file as: `copilot_logs/TASK_NAME.md`
:::

and include it in your Pull Request.

This takes Copilot a few seconds and keeps our PRs tidy, transparent, and genuinely "reviewable."

------------------------------------------------------------------------

#### **Prompt Files Are Optional Tools, Not Documentation** {.unnumbered}

Copilot has something called **Prompt Files**, which lets you save reusable instructions like:

-   “Use data.table, not dplyr.”
-   “Follow collapse idioms.”
-   “Write tests using testthat.”

These are great for giving Copilot consistent context, but they *don’t* replace the documentation required above.

Use them if they help you, but they’re optional.

------------------------------------------------------------------------

#### **Final Thought** {.unnumbered}

This protocol isn’t about bureaucracy. It’s about making sure that Copilot becomes a *collaborator*, not a shadow author.

When you keep a clear record of the interaction, everyone on the team benefits—your reviewers, the teammates who maintain your code, and you in the future.

And yes: you’ll get faster at this than you think. After a few tasks, it becomes second nature and saves you time rather than adding work.

Below is the **conversational, polished, markdown-ready version of Protocol 2**, written in the same friendly but authoritative style as Protocol 1. I’ve integrated your two additional requirements:

1.  **Copilot must insert human-readable comments directly inside the code (the WHAT and the WHY).**
2.  **All R functions must include proper Roxygen2 documentation.**

Both are incorporated naturally into the flow.

You can copy/paste this directly into your main document.

------------------------------------------------------------------------

### **Protocol 2 — Validating What Copilot Generates**

**Objective:** Once Copilot produces code, we need to make sure that it’s correct, understandable, and safe, *before* it ever reaches the repository. This protocol is not about forcing you to manually check every line of code. Instead, it’s about using Copilot intelligently as a validation partner.

Our goal here is simple: **If Copilot wrote something, then Copilot should also help us understand it, document it, critique it, and test it.** ---

#### **Ask Copilot to Explain the Code Step-by-Step** {.unnumbered}

Right after Copilot generates a function, script, or refactor, ask:

::: {.callout-note icon="false" appearance="simple"}
## Prompt

Explain this code step-by-step. Describe the purpose of each major block. List all assumptions you’re making. Identify any cases where this code might break.
:::

You’re not expected to decipher the code alone. This step forces Copilot to surface the hidden logic behind its decisions—and gives you a clear foundation for understanding what’s going on.

Include this explanation in your task summary.

------------------------------------------------------------------------

#### **Ask Copilot to Add In-Code Comments Explaining Both the “What” and the “Why”** {.unnumbered}

Once the general explanation is clear, you must ask Copilot:

::: {.callout-note icon="false" appearance="simple"}
## Prompt

Add clear comments directly inside the code. Explain:

-   what each major block does
-   why this approach is being used
-   why this logic or pattern is appropriate here
:::

These comments are essential because:

-   They ensure the logic is transparent.
-   They help future maintainers (including you).
-   They reduce the cognitive load when reviewing complex Copilot output.

We want readable, human-language explanations—not machine translations of the code.

------------------------------------------------------------------------

#### **Ask Copilot to Document All R Functions Using Roxygen2** {.unnumbered}

If the output includes R functions, you must also request:

::: {.callout-note icon="false" appearance="simple"}
## Prompt

Add proper Roxygen2 documentation for all R functions. Include:

-   \@title
-   \@description
-   \@param
-   \@return
-   \@examples (if useful)
-   \@import / \@importFrom (only when truly necessary)
:::

This step ensures:

-   The function interfaces are clear.
-   The expected inputs/outputs are known.
-   Reviewers can understand intent without reading the body.
-   Packages remain maintainable.

We want **professional-grade documentation** from the start, not as an afterthought.

------------------------------------------------------------------------

#### **Ask Copilot to Build a Validation Checklist** {.unnumbered}

Before moving on, request:

::: {.callout-note icon="false" appearance="simple"}
## Prompt

Create a validation checklist for this code. Include: - expected inputs and outputs - potential failure points - required dependencies - edge cases to test - assumptions this code relies on
:::

This checklist goes into your summary and becomes a quick-reference tool for reviewers.

------------------------------------------------------------------------

#### **Ask Copilot to Critique Its Own Code** {.unnumbered}

Though it may sound weird, this might be the most powerful step.

Prompt Copilot with:

::: {.callout-note icon="false" appearance="simple"}
## Prompt

Review your own code as if you were performing a formal code review. Identify:

-   inefficiencies
-   unnecessary complexity
-   risky assumptions
-   unclear logic
-   places where `data.table`, `collapse`, or `rlang` might be more appropriate
:::

Copilot is surprisingly good at pointing out its own flaws when prompted this way. Use its critique to improve the final version.

Notice that the last line specifically asks Copilot to check for compatibility with our preferred packages and coding styles. These are the ones that I (Andrés) use the most, but make sure you adapt them to your package or projects standards.

------------------------------------------------------------------------

#### **Ask Copilot to Provide a Plain-Language Overview of the Logic** {.unnumbered}

This is different from comments or Roxygen2 documentation.

You should ask:

::: {.callout-note icon="false" appearance="simple"}
## Prompt

Write a short, plain-language explanation of how this code works. Pretend you're explaining it to a teammate seeing it for the first time.
:::

This summary helps:

-   New team members ramp up quickly
-   Reviewers understand context without digging
-   Future maintainers get immediate clarity

This explanation goes into the task summary.

------------------------------------------------------------------------

#### **Ask Copilot to Generate Unit Tests and Edge Cases** {.unnumbered}

No Copilot-generated code is considered “validated” until Copilot helps you test it.

::: {.callout-note icon="false" appearance="simple"}
## Prompt For R:

Generate testthat unit tests. Cover:

-   normal cases
-   edge cases
-   wrong input types
-   missing values
-   extreme or unusual data scenarios
:::

::: {.callout-tip icon="false" appearance="simple"}
## Prompt For Stata:

Generate do-file tests or assertions. Cover:

-   realistic data\
-   corner cases\
-   unexpected inputs
:::

These tests must be included in your PR.

------------------------------------------------------------------------

#### **Ask Copilot to Run a Dependency and Risk Scan** {.unnumbered}

If the code adds or modifies dependencies, request:

::: {.callout-note icon="false" appearance="simple"}

## Prompt:

Explain why each dependency is needed.
Suggest ways to remove or replace unnecessary dependencies.
Check for conflicts with data.table, collapse, or rlang.
Identify any security or stability concerns.

:::

This helps prevent dependency creep and ensures the code fits our ecosystem.

------------------------------------------------------------------------

#### **Package Everything Into a “Validation Bundle”** {.unnumbered}

Before closing your task, ask Copilot:

::: {.callout-note icon="false" appearance="simple"}

## Prompt:

Add all validation materials to the task summary:

- step-by-step explanation
- in-code comments added
- Roxygen2 documentation
- validation checklist
- self-critique
- plain-language explanation
- test cases (and edge cases)
- dependency and risk analysis

:::

This bundle provides everything reviewers need. It also ensures that anyone who maintains the code later won’t be flying blind.

------------------------------------------------------------------------

#### **Why This Protocol Matters** {.unnumbered}

The goal isn’t to slow you down. It’s to make sure that Copilot helps you; not replaces your thinking.

With this protocol:

-   You don’t have to manually inspect every line.
-   You don’t have to fully understand the code immediately.
-   You don’t have to memorize anything.
